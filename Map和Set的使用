自定义类型作为TreeMap的K
自定义类型作为TreeSet的E
要求：1.类型是Comparable的
      2.构造时传入Comparator
泛型中的父子类型（重要）
 MyArrayList<Object> 不是 MyArrayList<Number>的父类型
 MyArrayList<Number> 也不是 MyArrayList<Integer>的父类型
 需要使用通配符来确定父子类型
 MyArrayList<?> 是 MyyArrayList<? extends Number>的父类型
 MyArrayList<? extends Number>是 MyArrayList<Integer>的父类型
 泛型的限制：
    1）泛型类型参数不支持基本数据类型
    2）无法实例化泛型类型的对象
    3）无法使用泛型类型声明静态的属性
    4）无法使用instanceof判断带类型参数的泛型类型
    5）无法创建泛型类数组
    6）无法create,catch,throw一个泛型类异常（异常不支持泛型）
    7）泛型类型不是形参一部分，无法重载
 关于泛型
 1.类型：泛型类/泛型方法
 2.泛型：一定要区分泛型的定义还是使用
 3.把握E...是一个类型变量，有其作用域
       类名称后面的是定义类型变量，其余位置都是使用
 4.谁是谁的父类的问题
    List<Object> 不是List<String> 的父类
    List<?> 是 List<String> 的父类
 5.泛型是编译期间的工作

 Hash  HashMap/HashSet
    实现搜索的数据结构
     String s="....";//字符串中只会出现小写字母
     统计每个字母的出现次数
     int[]  count;
     核心：1.内部数据结构是数组
           2.关键字经过变换（hash函数）得到int类型的值
           3.int类型的值变成一个合法的数组下标
           4.把关键字放入数组的该下标位置
     哈希函数：
          hash(key)=key%capacity
     哈希冲突（哈希碰撞）：
          对于不同的key,经过哈希后，得到的下标是相同的
     哈希的问题都是围绕哈希冲突展开：
          哈希冲突越少越好
          理论：没可能，数组的容量n个，要放的数据m个
                 m>>n
         1. 如何尽可能的减少哈希冲突的次数
             解决办法：
             1）哈希函数的设计（尽可能的让出来的下标符合均匀分布）
             2)负载因子的调节
                负载因子=哈希表中的数据个数/数组长度
                1.负载因子越少，冲突率越低
                2.数据个数不能动，所以把数组长度变大
                3.事先规定好一个阈值，来控制resize
         2.真的冲突了怎么办
             解决办法：
              1）闭散列:线性探测    二次探测法
例题：1.数组长度10，放入的关键字是21,15,30,36,25,40,26,37  线性探测法  求：查找成功的平均查找长度  查找失败的平均查找长度
       平均查找长度=查找次数/数据个数
      2.数组长度：9
        关键字3,14,2,11,7,5
        成功：（1+1+3+1+2+1）/6=1.5
        失败：（1+1+7+6+5+4+3+2+1）/9=3.4
2.哈希桶（拉链法/开散列）：
